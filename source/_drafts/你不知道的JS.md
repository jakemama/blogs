---
title: 《你不知道的JS》上卷
tags:
  - 笔记
categories:
  - 前端
---
## 1.编译
- 分词/词法分析：将字符组成的字符串分解成有意义的代码块
- 解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的抽象语法树（AST）
- 代码生成：将AST转换成可执行代码

上面是传统编译语言的流程，JS的编译过程不是发生在构建之前，而是发生在代码执行前

## 2.LHS和RHS查找
LHS和RHS是引擎对变量的查找方式，L和R代表的是一个赋值操作的左侧和右侧。可以理解为赋值和取值。

`console.log(a)`对a是引用是RHS饮用，这里a并没有赋予任何值  

`a = 2`对a的引用是LHS引用

为什么要区分LHS和RHS呢？当你未声明该变量时，进行RHS查询会抛出ReferenceError异常，而LHS查询会在全局作用域中创建一个该名称变量，但如果在严格模式下，禁止自动或隐式创建全局变量，也会抛出ReferenceError异常。如果RHS找到一个变量，但是对其进行不合理操作，会抛出TypeError异常。

RefersnceError同作用域判别失败有关，而TypeError则代表作用域判别成功，但是对结果的操作是非法的

## 3.匿名和具名函数
匿名函数的几个缺点
1. 调试困难：匿名函数在栈追踪中不会显示出有意义的函数名
2. 引用自身时只能使用已过期的arguments.callee引用：比如在递归中和事件触发后事件监听器需要解绑自身
3. 可读性、可理解性下降：一个描述性名称可以让代码不言自明

## 4. 块作用域
将变量绑定在所在块作用域（{...}）ES6用let，之前用try/catch的catch块。

## 5. 变量提升
变量的声明会提到作用域的最上方，并且函数声明优先。

## 6. 闭包
当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这是就产生了闭包

## 7. 箭头函数
箭头函数在涉及绑定时的行为和普通函数的行为完全不一致。她放弃了所有普通this绑定的规则，取而代之的是用当前的词法作用域覆盖了this的值

相当于在函数外声明了`that = this`，然后在函数内使用that来绑定

也可以在函数后面加上`bind(this)`，也和箭头函数等价。但可以避免使用新特性。